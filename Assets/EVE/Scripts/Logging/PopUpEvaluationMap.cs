using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Xml.Serialization;
using System;

/// <summary>
///   The pop up evalaution map allows experiments to quickly view participants paths
///   through an experiment scene.
/// </summary>
/// <revisionHistory visible="true">
///   <revision date = "2016-08-19" version="0.1.1.1" author="Jascha Grübel" visible="true">
///     Introduce dynamic map loading.
///   </revision>
/// </revisionHistory>
public class PopUpEvaluationMap : MonoBehaviour
{
    //General settings
    [Tooltip("Texture for the participant path.")]
    public Texture participantPathTexture;
    [Tooltip("Texture of the close button.")]
    public Texture closeX;
    [Tooltip("Map height on the evaluation screen.")]
    public float mapHeight = 512;
    [Tooltip("Map width on the evaluation screen.")]
    public float mapWidth = 512;
    [Tooltip("Resolution of the original map.")]
    public int resolution = 2048;

    //Derived settings data
    private float top;
    private float left;
    private Vector2 size;
    private bool displayMapPopup;

    //map data
    private List<Vector2> participantLocationsOnMap = new List<Vector2>();
    private Dictionary<string, Matrix4x4> projectionMatrices;
    private Dictionary<string, Matrix4x4> worldToCameraMatrices;
    private Dictionary<string, Texture> mapTextures;
    private List<string> uniqueNames;
    private string currentMapToDisplay;

    /// <summary>
    /// Initialised derived settings.
    /// </summary>
    public void Awake()
    {
        displayMapPopup = false;

        // calculate size of the map on screen
        top = (Screen.height - mapHeight) / 2.0f;
        left = (Screen.width - mapWidth) / 2.0f;
        size = new Vector2(participantPathTexture.width, participantPathTexture.height);
    }

    /// <summary>
    /// Displays the popup map.
    /// </summary>
    public void OnGUI()
    {
        if (displayMapPopup)
        {
            GUI.depth = 0;

            //draw background texture
            if (mapTextures.ContainsKey(currentMapToDisplay))
            {
                GUI.DrawTexture(new Rect(left, top, mapWidth, mapHeight), mapTextures[currentMapToDisplay]);
            }

            //draw participant path
            for (int i = 0; i < participantLocationsOnMap.Count; i++)
            {
                GUI.DrawTexture(new Rect(participantLocationsOnMap[i], size), participantPathTexture);
            }

            // Show close button
            if (GUI.Button(new Rect(left + mapWidth * 1.02f, top + mapHeight * -0.04f, 40f, 40f), closeX, GUIStyle.none))
            {
                displayMapPopup = false;
            }
        }
    }

    /// <summary>
    /// Opens a map displaying a participants route through the scene.
    /// </summary>
    /// <param name="xyz">Participant's location data</param>
    /// <param name="mapName">Name of the scene</param>
    public void OpenPopUpMap(float[][] xyz, string mapName)
    {
        currentMapToDisplay = mapName;
        displayMapPopup = true;
        float top = (Screen.height - mapHeight) / 2;
        float left = (Screen.width - mapWidth) / 2;
        participantLocationsOnMap.Clear();
        List<Vector2> tempParticipantLocationsOnMap = new List<Vector2>();
        for (int i = 0; i < xyz.Length; i++)
        {
            Vector3 worldLocation = new Vector3(xyz[i][0], xyz[i][1], xyz[i][2]);
            Vector3 screenPoint = projectionMatrices[currentMapToDisplay].MultiplyPoint(worldToCameraMatrices[currentMapToDisplay].MultiplyPoint(worldLocation));
            Vector2 screenPixel = new Vector2(left + (screenPoint[0] + 0.5f) * mapWidth, top + (-screenPoint[1] + 1.0f) * 0.5f * mapHeight);

            tempParticipantLocationsOnMap.Add(screenPixel);
        }
        for (int i = 0; i < tempParticipantLocationsOnMap.Count - 1; i++)
        {
            Vector2 a = tempParticipantLocationsOnMap[i];
            Vector2 b = tempParticipantLocationsOnMap[i + 1];
            int dist = (int)(a - b).magnitude + 1;
            for (int j = 0; j <= dist; j++)
            {
                participantLocationsOnMap.Add(a + (b - a) * ((float)j / dist));
            }
        }
    }

    /// <summary>
    /// Loads all maps from the persistent data path.
    /// </summary>
    /// <remarks>
    /// The maps need to be generated by placing an `EvaluationCamera`-Prefab in the scene.
    /// </remarks>
    /// <param name="envNames">List of map names</param>
    internal void SetupMaps(string[][] envNames)
    {
        uniqueNames = new List<string>();
        for (int i = 0; i < envNames.Length; i++)
        {
            for (int j = 0; j < envNames[i].Length; j++)
            {
                if (!uniqueNames.Contains(envNames[i][j]) && !envNames[i][j].Contains(".xml"))
                {
                    uniqueNames.Add(envNames[i][j]);
                }
            }
        }

        projectionMatrices = new Dictionary<string, Matrix4x4>();
        worldToCameraMatrices = new Dictionary<string, Matrix4x4>();
        mapTextures = new Dictionary<string, Texture>();
        for (int i = 0; i < uniqueNames.Count; i++)
        {
            try
            {
                string path = Application.persistentDataPath + "/maps/" + uniqueNames[i] + "_worldToCameraMatrix.xml";

                XmlSerializer xmls = new XmlSerializer(new Matrix4x4().GetType());
                using (var stream = File.OpenRead(path))
                {
                    worldToCameraMatrices.Add(uniqueNames[i], (Matrix4x4)xmls.Deserialize(stream));
                }
                path = Application.persistentDataPath + "/maps/" + uniqueNames[i] + "_projectionMatrix.xml";
                using (var stream = File.OpenRead(path))
                {
                    projectionMatrices.Add(uniqueNames[i], (Matrix4x4)xmls.Deserialize(stream));
                }
            }
            catch (Exception ex)
            {
                Debug.LogError("A matrix for " + uniqueNames[i] + " was not found:\n" + ex.StackTrace);
            }
            StartCoroutine(LoadMap(uniqueNames[i], resolution));
        }

    }

    /// <summary>
    /// Loads the map as a resource from the persistent data path
    /// </summary>
    /// <param name="mapName"></param>
    /// <returns></returns>
    private IEnumerator LoadMap(string mapName, int resolution)
    {
        string path = "file:///" + Application.persistentDataPath + "/maps/" + mapName + "_" + resolution + "x" + resolution + ".png";

        WWW www = new WWW(path);
        yield return www;
        Texture2D tmpTex = new Texture2D(2, 2);
        www.LoadImageIntoTexture(tmpTex);
        mapTextures.Add(mapName, tmpTex);
    }
}
