//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Linq;
using System.Xml;
using System.Text.RegularExpressions;

public class QuestionFactory
{
	private int questionID;
	private int labelCount;
	private string currentText;
	private string currentKey;
	private string currentValue;
	public Dictionary<string, Dictionary<string, Question>> questionSets;
    public Dictionary<string, Dictionary<string, QuestionJumpImport>> jumpSets;
	
	private Dictionary<string, Question> currentQuestionSet;
    private Dictionary<string, QuestionJumpImport> currentJumpSet;
	
	private LoggingManager log;

	
	Dictionary<string, string> questionSetKeys;
	Dictionary<string, Dictionary<string, string>> questionJumpKeys;
	Dictionary<string, Dictionary<string, string>> questionLabelKeys;
	Dictionary<string, Dictionary<string, string>> questionValueKeys;
	Dictionary<string, Dictionary<string, string>> questionTextKeys;
	Dictionary<string, string> questionKeys;
	Dictionary<string, string> textKeys;
	Dictionary<string, string> textValues;
	Dictionary<string, string> valueKeys;
	Dictionary<string, string> labelKeys;
	Dictionary<string, string> jumpKeys;
	Dictionary<string, string> jumpValues;
	ArrayList jumpTable;

	XmlTextReader textReader;

	bool inQuestionSet;
	bool inQuestion;
	bool inText;
	bool inValue;
	bool inLabel;
	bool inJump;

    public QuestionFactory(string[] files, LoggingManager log)
    {

		this.log = log;

		this.questionID = 0;
		questionSets = new Dictionary<string, Dictionary<string, Question>> ();
        jumpSets = new Dictionary<string, Dictionary<string, QuestionJumpImport>>();
		foreach (string file in files) {
			textReader = new XmlTextReader (file);
			
			currentQuestionSet = new Dictionary<string, Question > ();
			textReader.Read ();
		
			// If the node has value

			string text = "";
			text += "XmlTextReader Properties Test\n";

			bool validQuestionnaire = true;

			this.inQuestionSet = false;
			this.inQuestion = false;
			this.inText = false;
			this.inValue = false;
			this.inLabel = false;
			this.inJump = false;
		
			this.currentText = "";
			this.currentKey = "";
			this.currentValue = "";

			questionSetKeys = new Dictionary<string, string> ();


			questionLabelKeys = new Dictionary<string, Dictionary<string, string>> ();
			questionJumpKeys = new Dictionary<string, Dictionary<string, string>> ();
			questionValueKeys = new Dictionary<string, Dictionary<string, string>> ();
			questionTextKeys = new Dictionary<string, Dictionary<string, string>> ();
			questionKeys = new Dictionary<string, string> ();
			textKeys = new Dictionary<string, string> ();
			textValues = new Dictionary<string, string> ();
			valueKeys = new Dictionary<string, string> ();
			labelKeys = new Dictionary<string, string> ();
			jumpKeys = new Dictionary<string, string> ();
			jumpValues = new Dictionary<string, string> ();
			
			jumpTable = new ArrayList();

			labelCount = 0;

			while (textReader.Read() && validQuestionnaire) {
			
				XmlNodeType nType = textReader.NodeType;

				// skip empty node types
				if (nType == XmlNodeType.Whitespace) {				
					//Debug.Log("Skip WhiteSpace");
					continue;
				} 
				//backtrack state in end-nodes and store complete questions
				else if (nType == XmlNodeType.EndElement) {
					BacktrackState();
				} 
				// extract meta data from structural elements
				else if (nType == XmlNodeType.Element) {
					ClassifyNode();
					ExtractAttributes();
				}
				// extract content of text element
				else  if (nType == XmlNodeType.Text) {
					ExtractContent();
				} else {
					Debug.LogWarning ("Unhandled XML Node: " + nType.ToString () + " " + textReader.Name.ToString ());
				}
			}
            currentJumpSet = new Dictionary<String, QuestionJumpImport>();
			//CreateJumps();
            storeJumps();
			jumpSets.Add(questionSetKeys["name"], currentJumpSet);
			questionSets.Add(questionSetKeys["name"], currentQuestionSet);
			questionSetKeys.Clear ();
		}
	}

	//Cleanup state after reading a complete node. Create question when question element is closed.
	private void BacktrackState(){
		//Close question set
		if (textReader.Name.ToString () == "question_set") {
			//Debug.Log ("ElementEnd");
			inQuestionSet = false;
		} 
		//Close question
		else if (textReader.Name.ToString () == "question") {
			//Debug.Log ("\tQElementEnd");
			ParseQuestion ();
			ComputeJumps();
			questionKeys.Clear ();
			questionValueKeys.Clear ();
			questionLabelKeys.Clear ();
			questionTextKeys.Clear ();
			questionJumpKeys.Clear ();
			textValues.Clear ();
			jumpValues.Clear ();
			labelCount = 0;
			inQuestion = false;
		}
		//Close text element
		else if (textReader.Name.ToString () == "text") {
			//Debug.Log ("\t\tTElementEnd");
			questionTextKeys.Add (textKeys["type"],textKeys);
			textKeys = new Dictionary<string, string> ();
			inText = false;
		}
		//Close value element
		else if (textReader.Name.ToString () == "value") {
			//Debug.Log ("\t\tVElementEnd");
			questionValueKeys.Add (valueKeys["type"],valueKeys);
			valueKeys = new Dictionary<string, string> ();
			inValue = false;
		}
		//Close label element
		else if (textReader.Name.ToString () == "label") {
			//Debug.Log ("\t\tLElementEnd");
			questionLabelKeys.Add (labelKeys["type"],labelKeys);
			labelCount++;
			labelKeys = new Dictionary<string, string> ();
			inLabel = false;
		} 
		//Close jump element
		else if (textReader.Name.ToString () == "jump") {
			//Debug.Log ("\t\tJElementEnd");
			questionJumpKeys.Add (jumpKeys["type"],jumpKeys);
			jumpKeys = new Dictionary<string, string> ();
			inJump = false;
		}
	}

	private void ClassifyNode(){
		//Only process valid question sets
		if (!inQuestionSet && textReader.Name.ToString () != "question_set") {
			Debug.LogError ("The xml does not contain a question set, but: " + textReader.Name.ToString ());
		}
		//Open question set
		else if (textReader.Name.ToString () == "question_set") {
			//Debug.Log ("Element: " + textReader.Name.ToString ());
			inQuestionSet = true;
		}
		//Only process if question is valid
		else if (!inQuestion && textReader.Name.ToString () != "question") {
			Debug.LogError ("The xml does not contain a question, but: " + textReader.Name.ToString ());
		}
		//Open question
		else if (textReader.Name.ToString () == "question") {
			//Debug.Log ("\tQElement: " + textReader.Name.ToString ());
			inQuestion = true;
		}
		//Read elements in question
		else if (inQuestionSet && inQuestion) {
			//Open a text
			if (textReader.Name.ToString () == "text") {
				//Debug.Log ("\t\tTElement: " + textReader.Name.ToString ());
				inText = true;
			}
			//Open a value
			else if (textReader.Name.ToString () == "value") {
				//Debug.Log ("\t\tVElement: " + textReader.Name.ToString ());
				inValue = true;
			}
			//Open a label
			else if (textReader.Name.ToString () == "label") {
				//Debug.Log ("\t\tLElement: " + textReader.Name.ToString ());
				inLabel = true;
			}
			//Open a jump
			else if (textReader.Name.ToString () == "jump") {
				//Debug.Log ("\t\tJElement: " + textReader.Name.ToString ());
				inJump = true;
			} else {
				//Debug.LogError ("Undefined question child: " + textReader.Name.ToString ());
			}
		} else {
			Debug.LogError ("Undefined: " + textReader.Name.ToString ());
		}
	}

	private void ExtractAttributes(){
		if (textReader.AttributeCount > 0) {
			//read out question set attributes
			if (!inQuestion && !inText && !inValue && !inLabel && !inJump) {
				for (int attInd = 0; attInd < textReader.AttributeCount; attInd++) {
					textReader.MoveToAttribute (attInd);
					currentValue = textReader.Value;
					if (textReader.Name == "name")
						currentKey = currentValue;
					//Debug.Log ("\t\tAttribute: " + textReader.Name + " - " + currentValue);
					questionSetKeys.Add (textReader.Name, currentValue);
				}
			}
			//read out question attributes
			else 	if (inQuestion && !inText && !inValue && !inLabel && !inJump) {
				for (int attInd = 0; attInd < textReader.AttributeCount; attInd++) {
					textReader.MoveToAttribute (attInd);
					currentValue = textReader.Value;
					if (textReader.Name == "name")
						currentKey = currentValue;
					//Debug.Log ("\t\t\tQAttribute: " + textReader.Name + " - " + currentValue);
					questionKeys.Add (textReader.Name, currentValue);
				}
			}
			//read out text element attributes
			else if (inText) {
				for (int attInd = 0; attInd < textReader.AttributeCount; attInd++) {
					textReader.MoveToAttribute (attInd);
					currentValue = textReader.Value;
					if (textReader.Name == "type")
						currentKey = currentValue;
					//Debug.Log ("\t\t\tTAttribute: " + textReader.Name + " - " + currentValue);
					textKeys.Add (textReader.Name, currentValue);
				}
			}
			//read out value element attributes
			else if (inValue) {
				for (int attInd = 0; attInd < textReader.AttributeCount; attInd++) {
					textReader.MoveToAttribute (attInd);
					currentValue = textReader.Value;
					if (textReader.Name == "type")
						currentKey = currentValue;
					//Debug.Log ("\t\t\tVAttribute: " + textReader.Name + " - " + currentValue);
					valueKeys.Add (textReader.Name, currentValue);
				}
			}
			//read out label element attributes
			else if (inLabel) {
				for (int attInd = 0; attInd < textReader.AttributeCount; attInd++) {
					textReader.MoveToAttribute (attInd);
					currentValue = textReader.Value;
					if (textReader.Name == "type")
						currentKey = currentValue;
					//Debug.Log ("\t\t\tLAttribute: " + textReader.Name + " - " + currentValue);
					labelKeys.Add (textReader.Name, currentValue);
				}
			}
			//read out jump element attributes
			else if (inJump) {
				for (int attInd = 0; attInd < textReader.AttributeCount; attInd++) {
					textReader.MoveToAttribute (attInd);
					currentValue = textReader.Value;
					if (textReader.Name == "type")
						currentKey = currentValue;
					//Debug.Log ("\t\t\tJAttribute: " + textReader.Name + " - " + currentValue);
					jumpKeys.Add (textReader.Name, currentValue);
				}
			}
			textReader.MoveToElement (); 
		} else {
			Debug.LogError("Undefined question object: "  + textReader.Name.ToString ());
		}
	}

	private void ExtractContent(){
        //Read out text content
	    try
	    {
	        if (inQuestionSet && inQuestion && inText)
	        {
	            currentText = textReader.Value.ToString();
	            //Debug.Log ("\t\t\tTContent: " + currentKey + " - " + currentText);
	            textValues.Add(currentKey, Regex.Unescape(currentText.Trim()));
	        }
	        //Read out value content
	        else if (inQuestionSet && inQuestion && inValue)
	        {
	            currentText = textReader.Value.ToString();
	            //Debug.Log ("\t\t\tVContent: " + currentKey + " - " + currentText);
	            textValues.Add(currentKey, Regex.Unescape(currentText.Trim()));
	        }
	        //Read out label content
	        else if (inQuestionSet && inQuestion && inLabel)
	        {
	            currentText = textReader.Value.ToString();
	            //Debug.Log ("\t\t\tLContent: " + currentKey + " - " + currentText);
	            textValues.Add(currentKey, Regex.Unescape(currentText.Trim()));
	        }
	        //Read out jump content
	        else if (inQuestionSet && inQuestion && inJump)
	        {
	            currentText = textReader.Value.ToString();
	            //Debug.Log ("\t\t\tJContent: " + currentKey + " - " + currentText);
	            jumpValues.Add(currentKey, Regex.Unescape(currentText.Trim()));
	        }
	        else
	        {
	            Debug.LogError("Undefined question content in " + textReader.Name.ToString() + ": " +
	                           textReader.Value.ToString());
	        }
	    }
	    catch (Exception e)
	    {
	        Debug.LogError("Already exists: " + currentKey + " with new text: " + currentText + " in " + currentQuestionSet);

	    }
	}

	//var decoded = HttpUtility.HtmlDecode("&lt; &gt; &amp;"); for escaped HTML
	private void ParseQuestion(){
		string name = questionKeys["name"];
		QuestionType type = GetQuestionType(questionKeys["answer"]);

		string question = "";
		string[] labels;
        int columns;
	    string key = "";
        List<int> outputList = new List<int>();
	    try
	    {
	        if (type != QuestionType.NOVALIDTYPE)
	        {
	            question = WWW.UnEscapeURL(textValues["question"]);
	            switch (type)
	            {
	                case QuestionType.TEXTANSWER:
	                    string val;
	                    int rowCount = int.Parse(questionKeys["rows"]);
	                    int colCount = 1;
	                    if (questionKeys.TryGetValue("columns", out val))
	                        colCount = int.Parse(val);
	                    labels = new string[labelCount];
	                    for (int j = 0; j < labelCount; j++)
	                    {
	                        labels[j] = textValues["field" + (1 + j)];
	                    }
	                    currentQuestionSet.Add(name, new TextQuestion(
	                        name,
	                        question,
	                        new int[2] {rowCount, colCount},
	                        labels,
	                        questionSetKeys["name"],
	                        log
	                    ));
	                    break;
	                case QuestionType.MULTIPLECHOICEANSWER:
	                    labels = new string[labelCount];
	                    columns = int.Parse(questionKeys["columns"]);
	                    if (columns == 1)
	                    {
	                        for (int j = 0; j < labelCount; j++)
	                        {
                                key = "choice" + (1 + j);
                                if (textValues.ContainsKey(key))
                                {
                                    labels[j] = textValues[key];
                                }
                                else
                                {
                                    labels[j] = "";
                                }
                            }
	                        for (int j = 0; j < labelCount; j++)
	                        {
	                            key = "choice" + (1 + j);
	                            if (questionLabelKeys[key].Count > 1)
	                            {
	                                if (questionLabelKeys[key].ContainsKey("output"))
	                                {
	                                    outputList.Add(int.Parse(questionLabelKeys[key]["output"]));
	                                    //Debug.Log(questionLabelKeys[key]["output"]);
	                                }
	                            }
	                        }
	                        currentQuestionSet.Add(name, new MultipleChoiceQuestion(
	                            name,
	                            question,
	                            new int[2] { labelCount, 1 },
	                            labels,
	                            questionSetKeys["name"],
	                            log,
	                            outputList.ToArray()
	                        ));
	                    }
	                    else
	                    {
	                        for (int j = 0; j < columns; j++)
	                        {
	                            labels[j] = textValues["column" + (1 + j)];
	                        }
	                        for (int j = 0; j < labelCount - columns; j++)
	                        {
	                            labels[columns + j] = textValues["choice" + (1 + j)];
	                        }
	                        for (int j = 0; j < labelCount; j++)
	                        {
	                            key = "column" + (1 + j);
	                            if (questionLabelKeys.ContainsKey(key))
	                            {
	                                if (questionLabelKeys[key].ContainsKey("output"))
	                                {
	                                    outputList.Add(int.Parse(questionLabelKeys[key]["output"]));
	                                    //Debug.Log(questionLabelKeys[key]["output"]);
	                                }
	                            }
	                        }
	                        currentQuestionSet.Add(name, new MultipleChoiceQuestion(
	                            name,
	                            question,
	                            new int[2] {labelCount - columns, columns},
	                            labels,
	                            questionSetKeys["name"],
	                            log,
	                            outputList.ToArray()
	                        ));
	                    }

	                    break;
	                case QuestionType.SINGLECHOICEANSWER:
	                    labels = new string[labelCount];
	                    var images = new string[labelCount];

                        columns = int.Parse(questionKeys["columns"]);
	                    if (columns == 1)
	                    {
	                        for (int j = 0; j < labelCount; j++)
	                        {
                                key = "choice" + (1 + j);
                                if (textValues.ContainsKey(key))
	                            {
	                                labels[j] = textValues[key];
	                            }
	                            else
	                            {
	                                labels[j] = "";
	                            }
	                        }
	                        for (int j = 0; j < labelCount; j++)
	                        {
	                            key = "choice" + (1 + j);
	                            if (questionLabelKeys[key].Count > 1)
	                            {
	                                if (questionLabelKeys[key].ContainsKey("output"))
	                                {
	                                    outputList.Add(int.Parse(questionLabelKeys[key]["output"]));
	                                    //Debug.Log(questionLabelKeys[key]["output"]);
	                                }
	                                if (questionLabelKeys[key].ContainsKey("image"))
	                                {
	                                    images[j] = questionLabelKeys[key]["image"];
	                                }
	                            }
	                        }
                            //TODO: ADJUST SINGLE CHOICE ANSWER TO DISPLAY IMAGES IF AVAILABLE
	                        var hasImages = images.Any(s => !string.IsNullOrEmpty(s));
	                        if (hasImages)
                            {
                                currentQuestionSet.Add(name, new SingleChoiceQuestion(
                                    name,
                                    question,
                                    new int[2] {  labelCount, 1 },
                                    labels,
                                    questionSetKeys["name"],
                                    log,
                                    outputList.ToArray(),
                                    images
                                ));
                            }
	                        else
                            {
                                currentQuestionSet.Add(name, new SingleChoiceQuestion(
                                    name,
                                    question,
                                    new int[2] { labelCount, 1 },
                                    labels,
                                    questionSetKeys["name"],
                                    log,
                                    outputList.ToArray()
                                ));
                            }
	                    }
	                    else
	                    {
	                        for (int j = 0; j < columns; j++)
	                        {
                                key = "column" + (1 + j);
                                if (textValues.ContainsKey(key))
                                {
                                    labels[j] = textValues[key];
                                }
                                else
                                {
                                    labels[j] = "";
                                }
                            }
	                        for (int j = 0; j < labelCount - columns; j++)
	                        {
                                key = "choice" + (1 + j);
                                if (textValues.ContainsKey(key))
                                {
                                    labels[columns + j] = textValues[key];
                                }
                                else
                                {
                                    labels[columns + j] = "";
                                }
	                        }
	                        for (int j = 0; j < labelCount; j++)
	                        {
	                            key = "column" + (1 + j);
	                            if (questionLabelKeys.ContainsKey(key))
	                            {
	                                if (questionLabelKeys[key].ContainsKey("output"))
	                                {
	                                    outputList.Add(int.Parse(questionLabelKeys[key]["output"]));
	                                }
	                            }
	                        }

	                        currentQuestionSet.Add(name, new SingleChoiceQuestion(
	                            name,
	                            question,
	                            new int[2] {labelCount - columns, columns},
	                            labels,
	                            questionSetKeys["name"],
	                            log,
	                            outputList.ToArray()
	                        ));
	                    }
	                    break;
	                case QuestionType.SLIDERANSWER:
	                    int numberOfQuestions = labelCount/3;
	                    labels = new string[labelCount];
	                    for (int j = 0; j < numberOfQuestions; j++)
	                    {
	                        labels[j] = textValues["scale" + (1 + j) + "_neg"];
	                    }
	                    for (int j = 0; j < numberOfQuestions; j++)
	                    {
	                        labels[numberOfQuestions + j] = textValues["scale" + (1 + j) + "_pos"];
	                    }
	                    for (int j = 0; j < numberOfQuestions; j++)
	                    {
	                        labels[2*numberOfQuestions + j] = textValues["question" + (1 + j)];
	                    }
	                    currentQuestionSet.Add(name, new SliderQuestion(
	                        name,
	                        question,
	                        new int[7] {numberOfQuestions, 0, 0, 0, labelCount, labelCount, labelCount},
	                        labels,
	                        questionSetKeys["name"],
	                        log
	                    ));
	                    break;
	                case QuestionType.MANIKINANSWER:
	                    string value,
	                        SAM_pn = "",
	                        SAM_pp = "",
	                        SAM_an = "",
	                        SAM_ap = "",
	                        SAM_dn = "",
	                        SAM_dp = "",
	                        scale1_neg = "",
	                        scale1_pos = "";
	                    if (textValues.TryGetValue("SAM_pleasure_neg", out value))
	                        SAM_pn = textValues["SAM_pleasure_neg"];
	                    if (textValues.TryGetValue("SAM_pleasure_pos", out value))
	                        SAM_pp = textValues["SAM_pleasure_pos"];
	                    if (textValues.TryGetValue("SAM_arousal_neg", out value))
	                        SAM_an = textValues["SAM_arousal_neg"];
	                    if (textValues.TryGetValue("SAM_arousal_pos", out value))
	                        SAM_ap = textValues["SAM_arousal_pos"];
	                    if (textValues.TryGetValue("SAM_dominance_neg", out value))
	                        SAM_dn = textValues["SAM_dominance_neg"];
	                    if (textValues.TryGetValue("SAM_dominance_pos", out value))
	                        SAM_dp = textValues["SAM_dominance_pos"];
	                    if (textValues.TryGetValue("scale1_neg", out value))
	                        scale1_neg = textValues["scale1_neg"];
	                    if (textValues.TryGetValue("scale1_pos", out value))
	                        scale1_pos = textValues["scale1_pos"];
	                    if (SAM_pn.Length > 0)
	                    {
	                        currentQuestionSet.Add(name, new ManikinQuestion(
	                            name,
	                            question,
	                            new int[2] {1, 9},
	                            new string[2] {SAM_pn, SAM_pp},
	                            questionSetKeys["name"],
	                            log
	                        ));
	                    }
	                    else if (SAM_an.Length > 0)
	                    {
	                        currentQuestionSet.Add(name, new ManikinQuestion(
	                            name,
	                            question,
	                            new int[2] {1, 9},
	                            new string[2] {SAM_an, SAM_ap},
	                            questionSetKeys["name"],
	                            log
	                        ));
	                    }
	                    else if (SAM_dn.Length > 0)
	                    {
	                        currentQuestionSet.Add(name, new ManikinQuestion(
	                            name,
	                            question,
	                            new int[2] {1, 9},
	                            new string[2] {SAM_dn, SAM_dp},
	                            questionSetKeys["name"],
	                            log
	                        ));
	                    }
	                    else if (scale1_neg.Length > 0)
	                    {
	                        currentQuestionSet.Add(name, new ManikinQuestion(
	                            name,
	                            question,
	                            new int[2] {1, 9},
	                            new string[2] {scale1_neg, scale1_pos},
	                            questionSetKeys["name"],
	                            log
	                        ));
	                    }
	                    break;
	                case QuestionType.LADDERANSWER:
	                    currentQuestionSet.Add(name, new LadderQuestion(
	                        name,
	                        question,
	                        null,
	                        new string[1] {WWW.UnEscapeURL(textValues["ladder"])},
	                        questionSetKeys["name"],
	                        log
	                    ));
	                    break;
	                case QuestionType.SINGLECHOICETEXTANSWER:
	                    int[] values = new int[labelCount + 3];
                        values[0] = labelCount;
                        values[1] = 1;
                        labels = new string[labelCount];
	                    for (int j = 0; j < labelCount; j++)
	                    {
	                        key = "choice" + (1 + j);
                            //find choices with user text answer
	                        if (questionLabelKeys[key].Count > 1)
	                        {
	                            if (questionLabelKeys[key].ContainsKey("answerable"))
	                            {
	                                if (questionLabelKeys[key]["answerable"] == "true")
	                                {
	                                    values[3 + j]++;
	                                    values[2]++;
	                                }
	                            }
	                        }
                            //save choice text
	                        labels[j] = textValues[key].Trim();
	                    }
	                    for (int j = 0; j < labelCount; j++)
	                    {
	                        key = "choice" + (1 + j);
	                        if (questionLabelKeys[key].Count > 1)
	                        {
	                            if (questionLabelKeys[key].ContainsKey("output"))
	                            {
	                                outputList.Add(int.Parse(questionLabelKeys[key]["output"]));
	                            }
	                        }
	                    }
	                    currentQuestionSet.Add(name, new SingleChoiceTextQuestion(
	                        name,
	                        question,
	                        values,
	                        labels,
	                        questionSetKeys["name"],
	                        log,
	                        outputList.ToArray()
	                    ));
	                    break;
	                case QuestionType.INFOSCREEN:
	                    currentQuestionSet.Add(name, new InfoScreenQuestion(
	                        name,
	                        question,
	                        null,
	                        null,
	                        questionSetKeys["name"],
	                        log
	                    ));
	                    break;
                    case QuestionType.MULTIPLECHOICETEXTANSWER:
                        int[] values2 = new int[labelCount + 3];
                        values2[0] = labelCount;
                        values2[1] = 1;
                        labels = new string[labelCount];
                        for (int j = 0; j < labelCount; j++)
                        {
                            key = "choice" + (1 + j);
                            //find choices with user text answer
                            if (questionLabelKeys[key].Count > 1)
                            {
                                if (questionLabelKeys[key].ContainsKey("answerable"))
                                {
                                    if (questionLabelKeys[key]["answerable"] == "true")
                                    {
                                        values2[3 + j]++;
                                        values2[2]++;
                                    }
                                }
                            }
                            //save choice text
                            labels[j] = textValues[key].Trim();
                        }
                        for (int j = 0; j < labelCount; j++)
                        {
                            key = "choice" + (1 + j);
                            if (questionLabelKeys[key].Count > 1)
                            {
                                if (questionLabelKeys[key].ContainsKey("output"))
                                {
                                    outputList.Add(int.Parse(questionLabelKeys[key]["output"]));
                                }
                            }
                        }
                        currentQuestionSet.Add(name, new MultipleChoiceTextQuestion(
                            name,
                            question,
                            values2,
                            labels,
                            questionSetKeys["name"],
                            log,
                            outputList.ToArray()
                        ));
                        break;
	                default:
	                    Debug.LogWarning("No valid type.");
	                    break;
	            }
	            this.questionID++;
	        }
	    }
	    catch (Exception e)
	    {
	        Debug.LogError(key + " " + e);
	    }
	}

	private void ComputeJumps(){

		foreach(Dictionary<string, string> jumpKeys in questionJumpKeys.Values){
			if (jumpKeys.Count > 0) {
				string key = jumpKeys ["type"];
				string orig = questionKeys["name"];
				string condition = jumpValues[key];
				string destination = jumpKeys ["destination"];
				JumpPlaceholder jump = new JumpPlaceholder(orig,destination,condition,questionJumpKeys.Values.Count);
				jumpTable.Add(jump);
				//Debug.Log ("From " + jump.orig + " to " + jump.dest + " if " + jump.condition);
			}
		}
	}

    private void storeJumps()
    {
        if (jumpTable.Count > 0)
        {
            string lastOrig = "";
            string[] destNames = new string[0];
            object[,] conditions = new object[0, 0];
            int jumpID = 0;
            foreach (JumpPlaceholder jumpPlaceholder in jumpTable)
            {
                if (jumpPlaceholder.orig == lastOrig)
                {
                    Question origQuestion = currentQuestionSet[jumpPlaceholder.orig];
                    String origQuestionName = origQuestion.GetQuestionName();
                    String destQuestionName = "";
                    Question destQuestion = null;
                    if (jumpPlaceholder.dest != "*")
                    {
                        destQuestion = currentQuestionSet[jumpPlaceholder.dest];
                        destQuestionName = destQuestion.GetQuestionName();
                    }
                    else
                    {
                        destQuestionName = "-1";
                    }
                    destNames[jumpID] = destQuestionName;
                    string condition = jumpPlaceholder.condition;

                    if (condition == "*")
                    {
                        conditions = null;
                    }
                    else
                    {
                        for (int i = 0; i < condition.Length; i++)
                        {
                            if (condition[i] == 'T')
                            {
                                conditions[jumpID, i] = true;
                            }
                            else
                            {
                                conditions[jumpID, i] = false;
                            }
                        }
                        if (jumpID == jumpPlaceholder.totalJumps - 1)
                        {
                            QuestionJumpImport jump = new QuestionJumpImport(origQuestionName, destNames, conditions);
                            currentJumpSet.Add(origQuestionName, jump);
                        }
                    }

                    jumpID++;
                   
                }
                else
                {
                    jumpID = 0;
                    lastOrig = jumpPlaceholder.orig;
                    destNames = new string[jumpPlaceholder.totalJumps];
                    conditions = new object[jumpPlaceholder.totalJumps, jumpPlaceholder.condition.Length];
                    Question origQuestion = currentQuestionSet[jumpPlaceholder.orig];
                    String origQuestionName = origQuestion.GetQuestionName();
                    String destQuestionName = "";
                    Question destQuestion = null;
                    if (jumpPlaceholder.dest != "*")
                    {
                        destQuestion = currentQuestionSet[jumpPlaceholder.dest];
                        destQuestionName = destQuestion.GetQuestionName();
                    }
                    else
                    {
                        destQuestionName = "-1";
                    }
                    destNames[jumpID] = destQuestionName;
                    string condition = jumpPlaceholder.condition;

                    if (condition == "*")
                    {
                        conditions = null;
                        if (jumpID == jumpPlaceholder.totalJumps - 1)
                        {
                            QuestionJumpImport jump = new QuestionJumpImport(origQuestionName, destNames, conditions);
                            currentJumpSet.Add(origQuestionName, jump);
                        }
                    }
                    else
                    {
                        for (int i = 0; i < condition.Length; i++)
                        {
                            if (condition[i] == 'T')
                            {
                                conditions[jumpID, i] = true;
                            }
                            else
                            {
                                conditions[jumpID, i] = false;
                            }
                        }
                        if (jumpID == jumpPlaceholder.totalJumps - 1)
                        {
                            QuestionJumpImport jump = new QuestionJumpImport(origQuestionName, destNames, conditions);
                            currentJumpSet.Add(origQuestionName, jump);
                        }
                    }

                    jumpID++;
                    
                }
            }
            if (jumpTable.Count == 1)
            {
                JumpPlaceholder jumpPlaceholder = (JumpPlaceholder)jumpTable[0];
                Question origQuestion = currentQuestionSet[jumpPlaceholder.orig];
                string origQuestionName = origQuestion.GetQuestionName();

                string destQuestionName = "";
                Question destQuestion = null;
                if (jumpPlaceholder.dest != "*")
                {
                    destQuestion = currentQuestionSet[jumpPlaceholder.dest];
                    destQuestionName = destQuestion.GetQuestionName();
                }
                else
                {
                    destQuestionName = "-1";
                }
                destNames[jumpID] = destQuestionName;
                string condition = jumpPlaceholder.condition;
                if (condition == "*")
                {
                    conditions = null;
                }
                else
                {
                    for (int i = 0; i < condition.Length; i++)
                    {
                        if (condition[i] == 'T')
                        {
                            conditions[jumpID, i] = true;
                        }
                        else
                        {
                            conditions[jumpID, i] = false;
                        }
                    }
                }
                QuestionJumpImport jump = new QuestionJumpImport(origQuestionName, destNames, conditions);
                currentJumpSet.Add(origQuestionName, jump);

            }
        }
    }
    
	private QuestionType GetQuestionType(string type){
		if (type == "TEXTANSWER")
        {
			return QuestionType.TEXTANSWER;
		}
        else if (type == "MULTIPLECHOICEANSWER")
        {
			return QuestionType.MULTIPLECHOICEANSWER;
		}
        else if (type == "SINGLECHOICEANSWER")
        {
			return QuestionType.SINGLECHOICEANSWER;
		}
        else if (type == "SLIDERANSWER")
        {
			return QuestionType.SLIDERANSWER;
		}
        else if (type == "MANIKINANSWER")
        {
			return QuestionType.MANIKINANSWER;
		}
        else if (type == "LADDERANSWER")
        {
			return QuestionType.LADDERANSWER;
		}
        else if (type == "SINGLECHOICETEXTANSWER")
        {
			return QuestionType.SINGLECHOICETEXTANSWER;
		}
        else if (type == "INFOSCREEN")
        {
            return QuestionType.INFOSCREEN;
		}
        else if (type == "MULTIPLECHOICETEXTANSWER")
        {
            return QuestionType.MULTIPLECHOICETEXTANSWER;
        }
        else
        {
            Debug.LogWarning("Unknown question of type: " + type);
			return QuestionType.NOVALIDTYPE;
        }

    }

	private class JumpPlaceholder {

		public string orig;
		public string dest;
		public string condition;
		public int totalJumps;

		public JumpPlaceholder(string orig, string dest, string condition, int totalJumps){
			this.orig = orig;
			this.dest = dest;
			this.condition = condition;
			this.totalJumps = totalJumps;
		}
	}

    public Dictionary<string, Dictionary<string, Question>> getQuestionSets()
    {
        return questionSets;
    }
}
